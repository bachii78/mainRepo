// Generated by CoffeeScript 1.11.1
(function() {
  var Breakpoint, BreakpointManager, CompositeDisposable, Disposable, Emitter, _, ref;

  ref = require('event-kit'), Emitter = ref.Emitter, Disposable = ref.Disposable, CompositeDisposable = ref.CompositeDisposable;

  _ = require('underscore');

  Breakpoint = (function() {
    function Breakpoint(gdb, bkpt) {
      this.gdb = gdb;
      this.emitter = new Emitter;
      _.extend(this, bkpt);
    }

    Breakpoint.prototype.onChanged = function(cb) {
      return this.emitter.on('changed', cb);
    };

    Breakpoint.prototype.onDeleted = function(cb) {
      return this.emitter.on('deleted', cb);
    };

    Breakpoint.prototype.remove = function() {
      return this.gdb.send_mi("-break-delete " + this.number).then((function(_this) {
        return function() {
          return _this._deleted();
        };
      })(this));
    };

    Breakpoint.prototype._changed = function(bkpt) {
      _.extend(this, bkpt);
      return this.emitter.emit('changed');
    };

    Breakpoint.prototype._deleted = function() {
      this.emitter.emit('deleted');
      return this.emitter.dispose();
    };

    return Breakpoint;

  })();

  module.exports = BreakpointManager = (function() {
    function BreakpointManager(gdb) {
      this.gdb = gdb;
      this.breaks = {};
      this.observers = [];
      this.subscriptions = new CompositeDisposable;
      this.subscriptions.add(this.gdb.onAsyncNotify(this._onAsyncNotify.bind(this)));
      this.subscriptions.add(this.gdb.exec.onStateChanged(this._onStateChanged.bind(this)));
    }

    BreakpointManager.prototype.observe = function(cb) {
      var bkpt, id, ref1;
      ref1 = this.breaks;
      for (id in ref1) {
        bkpt = ref1[id];
        cb(id, bkpt);
      }
      this.observers.push(cb);
      return new Disposable(function() {
        var ref2;
        return (ref2 = this.observers) != null ? ref2.splice(this.observers.indexOf(cb), 1) : void 0;
      });
    };

    BreakpointManager.prototype.insert = function(location, options) {
      var flags;
      flags = '';
      if (options != null ? options.temp : void 0) {
        flags += ' -t';
      }
      return this.gdb.send_mi("-break-insert " + flags + " " + location).then((function(_this) {
        return function(arg) {
          var bkpt;
          bkpt = arg.bkpt;
          return _this._add(bkpt);
        };
      })(this));
    };

    BreakpointManager.prototype.insertWatch = function(expr, hook) {
      return this.gdb.send_mi("-break-watch " + expr).then((function(_this) {
        return function(arg) {
          var wpt;
          wpt = arg.wpt;
          if (hook != null) {
            hook(wpt.number);
          }
          return _this.gdb.send_mi("-break-info " + wpt.number);
        };
      })(this)).then((function(_this) {
        return function(results) {
          return _this._add(results.BreakpointTable.body.bkpt[0]);
        };
      })(this));
    };

    BreakpointManager.prototype.toggle = function(file, line) {
      var bkpt, id, ref1, removed;
      ref1 = this.breaks;
      for (id in ref1) {
        bkpt = ref1[id];
        if (bkpt.fullname === file && +bkpt.line === line) {
          bkpt.remove();
          removed = true;
        }
      }
      if (!removed) {
        return this.insert(file + ":" + line);
      }
    };

    BreakpointManager.prototype.destroy = function() {
      var bkpt, n, ref1;
      this.subscriptions.dispose();
      ref1 = this.breaks;
      for (n in ref1) {
        bkpt = ref1[n];
        bkpt._deleted();
        delete this.breaks[n];
      }
      return delete this.observers;
    };

    BreakpointManager.prototype._add = function(bkpt) {
      var cb, i, len, ref1;
      bkpt = this.breaks[bkpt.number] = new Breakpoint(this.gdb, bkpt);
      bkpt.onDeleted((function(_this) {
        return function() {
          return delete _this.breaks[bkpt.number];
        };
      })(this));
      ref1 = this.observers;
      for (i = 0, len = ref1.length; i < len; i++) {
        cb = ref1[i];
        cb(bkpt.number, bkpt);
      }
      return bkpt;
    };

    BreakpointManager.prototype._onAsyncNotify = function(arg) {
      var bkpt, cls, id, ref1;
      cls = arg[0], (ref1 = arg[1], id = ref1.id, bkpt = ref1.bkpt);
      switch (cls) {
        case 'breakpoint-created':
          return this._add(bkpt);
        case 'breakpoint-modified':
          return this.breaks[bkpt.number]._changed(bkpt);
        case 'breakpoint-deleted':
          this.breaks[id]._deleted();
          return delete this.breaks[id];
      }
    };

    BreakpointManager.prototype._onStateChanged = function(arg) {
      var bkpt, id, ref1, state;
      state = arg[0];
      if (state === 'DISCONNECTED') {
        ref1 = this.breaks;
        for (id in ref1) {
          bkpt = ref1[id];
          bkpt._deleted();
        }
        return this.breaks = {};
      }
    };

    return BreakpointManager;

  })();

}).call(this);
